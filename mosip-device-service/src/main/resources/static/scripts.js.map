{"version":3,"sources":["src/assets/js/custom.js"],"names":[],"mappings":";AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,kBAAkB,wEAAwE;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;;AAGX;;AAEA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;;AAEA,oCAAoC,sBAAsB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;;AAEA;;AAEA,OAAO;AACP;AACA,OAAO;AACP;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA","file":"scripts.js","sourcesContent":["\r\n// The mjpeg url.\r\n//const url = \"http://127.0.0.1:4501/stream\";\r\n\r\n//JPEG starting bytes\r\nconst SOI = new Uint8Array(3);\r\nSOI[0] = 0xFF;\r\nSOI[1] = 0xDB;\r\nSOI[2] = 0xD8;\r\nconst CONTENT_LENGTH = 'CONTENT-LENGTH';\r\nconst TYPE_JPEG = 'image/jpeg';\r\n\r\nlet controller = new AbortController();\r\n\r\nfunction stop_streaming() {\r\n  controller.abort();\r\n  controller = new AbortController();\r\n}\r\n\r\nfunction start_streaming(url, dId, dSubId, tagId) {\r\n      interrupt = false;\r\n      var obj = { deviceId: dId, deviceSubId: dSubId };\r\n      fetch(url, {method: 'STREAM', body: JSON.stringify(obj), signal: controller.signal })\r\n      .then(response => {\r\n          if (!response.ok) {\r\n              throw Error(response.status+' '+response.statusText)\r\n          }\r\n\r\n          if (!response.body) {\r\n              throw Error('ReadableStream not yet supported in this browser.')\r\n          }\r\n\r\n          const reader = response.body.getReader();\r\n\r\n          let headers = '';\r\n          let contentLength = -1;\r\n          let imageBuffer = null;\r\n          let bytesRead = 0;\r\n\r\n          let reader1 = new FileReader();\r\n\r\n          reader1.onload = function() {\r\n            //let data = reader1.result; // data url\r\n            //console.log(\"data URL >>> \" + data);\r\n            document.getElementById(tagId).src = reader1.result;\r\n          };\r\n\r\n\r\n          // calculating fps. This is pretty lame. Should probably implement a floating window function.\r\n         let frames = 0;\r\n\r\n          /* setInterval(() => {\r\n              console.log(\"fps : \" + frames);\r\n              frames = 0;\r\n          }, 1000)*/\r\n\r\n\r\n          const read = () => {\r\n\r\n              reader.read().then(({done, value}) => {\r\n                  if (done) {\r\n                      controller.close();\r\n                      return;\r\n                  }\r\n\r\n                  for (let index =0; index < value.length; index++) {\r\n\r\n                      // we've found start of the frame. Everything we've read till now is the header.\r\n                      if (value[index] === SOI[0] && value[index+1] === SOI[2]) {\r\n                          //console.log('JPEG SOI marker found : ' + headers);\r\n                          contentLength = getLength(headers);\r\n                          // console.log(\"Content Length : \" + newContentLength);\r\n                          imageBuffer = new Uint8Array(contentLength);\r\n                      }\r\n                      // we're still reading the header.\r\n                      if (contentLength <= 0) {\r\n                          headers += String.fromCharCode(value[index]);\r\n                      }\r\n                      // we're now reading the jpeg.\r\n                      else if (bytesRead < contentLength){\r\n                          imageBuffer[bytesRead++] = value[index];\r\n                      }\r\n                      // we're done reading the jpeg. Time to render it.\r\n                      else {\r\n                          //console.log(\"jpeg read with bytes : \" + bytesRead);\r\n                          //URL.revokeObjectURL(document.getElementById('image').src);\r\n                          let blob = new Blob([imageBuffer.buffer], {type: TYPE_JPEG});\r\n                          //document.getElementById('image').src = URL.createObjectURL(blob);\r\n                          reader1.readAsDataURL(blob); // converts the blob to base64 and calls onload\r\n                          frames++;\r\n                          contentLength = 0;\r\n                          bytesRead = 0;\r\n                          headers = '';\r\n                      }\r\n                  }\r\n\r\n                  read();\r\n              }).catch(error => {\r\n                  console.error(error);\r\n              })\r\n          }\r\n\r\n          read();\r\n\r\n      }).catch(error => {\r\n          console.error(error);\r\n      })\r\n}\r\n\r\n\r\n\r\nconst getLength = (headers) => {\r\n    let contentLength = 0;\r\n    var parts = headers.split('\\r\\n');\r\n    headers.split('\\r\\n').forEach((header, _) => {\r\n        const pair = header.split(':');\r\n        if (pair[0].toUpperCase() === CONTENT_LENGTH) {\r\n        contentLength = parseInt(pair[1], 10);\r\n        }\r\n    })\r\n    return contentLength;\r\n};\r\n"],"sourceRoot":"webpack:///"}